### Grafos

Existem dois tipos principais de Grafos e são eles:

### Grafos Não-Direcionado
<span>A -------- B</span>  
Você pode ir de A para B e de B para A.

V = {"{A, B}"}  
E = {"{{A, B}}"}

### Grafos Direcionado
<span>A -------> B</span>  
Você pode ir de A para B e não pode ir de B para A.

V = {"{A, B}"}  
E = {"{(A, B)}"}


### Categoria de Grafos

- **Grafo Nulo**: Um Grafo sem arestas.

- **Grafo Simples**: Não possui loop e nem arestas paralelas.

- **Multigrafo**: Possui arestas paralelas.

- **Grafo Rotulado**: Possui rótulos nas arestas.

- **Grafo Ponderado**: Possui pesos nas arestas.

- **Grafo Completo**: Todos os vértices estão conectados.

- **Grafo Associado**: Um grafo associado a outro possui os mesmos vértices e as mesmas relações.

- **Grafo Regular**: Todos os vértices possuem o mesmo grau.

- **Grafo Conexo**: Existe um caminho entre todos os vértices, logo a partir de um vértice pode-se chegar em qualquer outro.

- **Grafo Bipartido**: Vértices podem ser divididos em dois conjuntos onde as arestas só podem ligar vértices de conjuntos diferentes.

- **Grafo Transposto**: Dado um grafo G, seu grafo transposto é o mesmo com arestas invertidas.

### Formúlas

- **Número de Arestas de um Grafo Não-Direcionado**: n(n-1)/2 (n = número de vértices)
- **Número de Arestas de um Grafo Direcionado**: n(n-1) (n = número de vértices)
- **Número de Arestas necessárias para um Grafo Regular**: n * k / 2 (n = número de vértices, k = grau do grafo)
- **Número de Arestas de um Grafo Bipartido Completo**: m * n (m = número de vértices de um conjunto, n = número de vértices do outro conjunto)
- **Número máximo de Arestas sabendo a quantidade de vérticies e componentes conexos**: (N-k+1)(n-k)/2 (N = número de vértices, k = número de componentes conexos)
- **Número de SubGrafos de um Grafo**: Somatorio de p

### Conceitos Básicos

- **Vertice Adjacente**: Dois vértices são adjacentes se eles são conectados por uma aresta.
- **Vértice Isolado**: Um vértice isolado é um vértice que não possui arestas conectadas a ele.
- **Vértice Pendente**: Um vértice pendente é um vértice que possui apenas uma aresta conectada a ele.
- **Aresta Paralela**: Duas arestas são paralelas se elas conectam os mesmos vértices.
- **Loop**: Um loop é uma aresta que conecta um vértice a ele mesmo.
- **Grau de um Vértice**: O grau de um vértice é o número de arestas conectadas a ele.
- **Grau de um Grafo**: O grau de um grafo é o maior grau de um vértice no grafo.
- **Componente Conexo**: Um componente conexo é um subgrafo de um grafo onde todos os vértices estão conectados.
- **Fecho Transitivo Direto**: O fecho transitivo direto de um vértice é o conjunto de vértices que podem ser alcançados a partir desse vértice.
- **Base ou Raiz**:Conjunto de todos vértices que contém grau de entrada igual a 0.
- **Anti-Base ou Anti-Raiz**: Conjunto de todos vértices que contém grau de saida igual a 0.
- **Excentricidade**: A excentricidade de um vértice é a maior distância entre ele e o vértice mais distante.
- **Distância**: A distância entre dois vértices é o número de arestas no caminho mais curto entre eles.
- **Diâmetro**: O diâmetro de um grafo é a maior excentricidade entre todos os vértices.
- **Raio**: O raio de um grafo é a menor excentricidade entre todos os vértices.
- **Centro**: O centro de um grafo é o conjunto de vértices que têm excentricidade igual ao raio.
- **Ponte**: Uma aresta cuja remoção aumenta o número de componentes conexos.
- **Articulação**: Um vértice cuja remoção aumenta o número de componentes conexos.

### SubGrafos

É um Grafo que possui um subconjunto de vértices e arestas de um Grafo original.

- **Subgrafo Induzido**: Um subgrafo induzido é um subgrafo que contém todos os vértices de um subconjunto de vértices e todas as arestas que conectam esses vértices.

### Busca em Profundidade

Fazer **buscas** em um grafo significa seguir suas arestas sistematicamente, de modo a visitar seus vérticies.

A estratégia seguida pela **Busca em Profundidade** é buscar o mais fundo possível sempre que possível.

Step by Step:
- Defina um vértice inicial e marque-o como visitado.
- Enquanto este não for um nó objetivo ou final (nó cuja adjacencia já tenha sido toda visitada)
- Selecione um vértice adjacente não visitado, visite-o e marque-o como visitado. 
- Se não houver vértices adjacentes não visitados, retroceda um nível na árvore de busca.
- Se não houver pai para retroceder, escolha outro nó inicial se existir.
- Caso não exista mais vértices para visitar, a busca termina.

[Assista ao vídeo](https://www.youtube.com/watch?v=doH9o1sO-Cw&t=574s)

### Busca em Largura

A estratégia seguida pela **Busca em Largura** é buscar o mais raso possível sempre que possível.

Ela primeiro visita todos os adjacentes de um vértice, depois visita os adjacentes dos adjacentes e assim por diante.

Muito boa para descobrir o melhor caminho entre dois vértices.

Step by Step:
- Defina um vértice inicial e marque-o como visitado.
- Enfileire-O
- Enquanto a fila não estiver vazia
    - Desenfileire um vértice
    - Para cada vértice adjacente não visitado
        - Marque-o como visitado
        - Enfileire-o
- Repita de outro nó inicial se existir.

[Assista ao vídeo](https://www.youtube.com/watch?v=RNJxSV3BmcI)

### Sequência de Vértices e Arestas

- **Walk**: Uma sequência de vértices e arestas que começa e termina em vértices.

- **Trail**: Walk em que as arestas não se repetem, mas os vértices podem.

- **Path**: Walk em que tanto os vértices quanto as arestas não se repetem.

- **Cycle**: Path em que o vértice inicial é o mesmo que o vértice final.

### Classificação das arestas

- **Aresta de Árvore (Tree Edge)**: É uma aresta que faz parte da árvore de busca em profundidade (DFS). Isso acontece quando um vértice é descoberto pela primeira vez ao seguir uma aresta.
Exemplo: Se você parte do vértice A e visita B pela primeira vez, a aresta (A, B) é uma aresta de árvore.

- **Aresta de Retorno (Back Edge)**: Essa aresta é utilizada para retornar a um vértice que já foi visitado durante a busca, criando um ciclo. Em termos de uma árvore de busca, é como "voltar no caminho" para um ancestral.
Exemplo: Durante a busca em profundidade, você chegou em C e percebe que C está conectado a um vértice já visitado (por exemplo, A). Nesse caso, (C, A) é uma aresta de retorno.

- **Aresta de Avanço (Forward Edge):**: Essa aresta não faz parte da árvore de busca, mas conecta um vértice a outro que já foi descoberto durante a busca em profundidade e é um descendente do vértice atual na árvore de busca.
Exemplo: Se durante a busca você já visitou B e encontra uma aresta entre A e B (que é um descendente de A), a aresta (A, B) é uma aresta de avanço.

- **Aresta de Cruzamento (Cross Edge)**: É uma aresta que conecta dois vértices de diferentes subárvores na árvore de busca ou conecta dois vértices dentro da mesma árvore, mas sem relação direta de ancestralidade.
Exemplo: Se durante a busca você encontra uma aresta entre dois vértices já visitados, mas que estão em ramos diferentes da árvore de busca, como (C, D), essa é uma aresta de cruzamento.

### Cut-Set

Um cut-set (ou conjunto de corte) em um grafo é um conjunto de arestas cujo removimento desconecta o grafo, ou seja, separa o grafo em dois ou mais componentes.

- **Cut-Set**: Um conjunto de arestas tal que, ao remover essas arestas, o grafo se torna desconexo (ou seja, uma ou mais partes do grafo ficam separadas).
- **Cut-Vertex**: Se uma única aresta no cut-set estiver conectada a um vértice, e a remoção dessa aresta e vértice causar a desconexão, esse vértice é chamado de cut-vertex (vértice de corte).

### Ciclo-Eureliano

Regras para a existência de um Ciclo Euleriano:
 - **Grafo não-direcionado**:
    Para que um Grafo tenha um ciclo euleriano, ele precisa ser conexo (exceto possivelmente pelos vértices isolados) e todos os vértices devem ter grau par.
 - **Grafo direcionado**:
    Para que um Grafo direcionado tenha um ciclo euleriano, ele precisa ser fortemente conexo (cada vértice é acessível a partir de qualquer outro vértice) e o grau de entrada deve ser igual ao grau de saída para todos os vértices.

### Diferença entre Caminho Euleriano e Ciclo Euleriano:

- **Caminho Euleriano**: É um caminho que percorre todas as arestas do grafo exatamente uma vez, mas não precisa ser fechado (não retorna ao ponto de partida).
- **Ciclo Euleriano**: É um caminho que percorre todas as arestas do grafo exatamente uma vez e termina no mesmo vértice em que começou.

### Isomorfismo

Propriedades do Isomorfismo:

- **Mesma quantidade de vértices**: Os grafos isomorfos têm o mesmo número de vértices.
- **Mesma quantidade de arestas**: Eles também têm o mesmo número de arestas.
- **Mesmo grau dos vértices**: Os vértices correspondentes nos dois grafos têm o mesmo grau (número de arestas conectadas).
- **Estrutura de conexões preservada**: Mesmas relações de incidências entre os vértices.


### Algoritmo para Classificar as Arestas

1 - Iniciar um vetor cores e como valor padrão Branco e um vetor classificação.
2 - Realizar uma busca em profundidade, a partir de um vértice de origem

Busca em Profundidade -> Seguir suas arestas sistematicamente, sempre procurando o vértice mais profundo, as arestas são exploradas a partir
do vértice mais recentemente descoberto que ainda tem arestas não visitadas.

3 - Durante a busca, enquanto houver vértices adjacentes 
    Se encontrado uma aresta (u, v) em que v é Branco, classificar aresta como aresta de árvore e marcar v como Azul
    chamar metodo recursivamente passando v

    Se encontrado uma aresta (u, v) em que v é azul, classificar aresta como aresta de retorno
    Se encontrado uma aresta (u, v) em que v é vermelho, se o tempo de inicio de u < v classificar como aresta de avanço, caso o contrário, aresta de cruzamento

4 - Caso não tenha mais vértices adjacentes, marcar V como vermelho 


### Algoritmo para encontrar Base

Base -> Conjunto de todos vértices que contém grau de entrada igual a 0.

1 - Cada vértice v terá uma lista de adjacência de sucessores, que são todos os vértices adjacentes de v, com arestas saindo de v.

2 - Realizar uma busca em profundidade, a partir de um vértice de origem

Busca em Profundidade -> Seguir todas as arestas sistematicamente, utilizando uma estrutura de pilha, sempre procurando o vértice mais profundo, as arestas são exploradas a partir do vértice
mais recentemente descoberto que ainda tem arestas não visitadas.

3 - Durante a busca, enquanto houver vértices adjacentes:
    Se encontrar uma aresta de retorno, contém um ciclo.

4 - Para cada ciclo, comprimir os vértices do ciclo em um hiper-vértice.

5 - Verificar lista de adjacência de sucessores, os vértices que não aparecem como sucessor, constituirao meu conjunto de bases.

### Algoritmo pra encontrar Anti-Base

Anti-Base -> Conjunto de todos vértices que contém grau de saida igual a 0.

1 - Cada vértice v terá uma lista de adjacência de sucessores, que são todos os vértices adjacentes de v, com arestas saindo de v.

2 - Realizar uma busca em profundidade, a partir de um vértice de origem

Busca em Profundidade -> Seguir todas as arestas sistematicamente, utilizando uma estrutura de pilha, sempre procurando o vértice mais profundo, as arestas são exploradas a partir do vértice
mais recentemente descoberto que ainda tem arestas não visitadas.

3 - Durante a busca, enquanto houver vértices adjacentes:
    Se encontrar uma aresta de retorno, contém um ciclo.

4 - Para cada ciclo, comprimir os vértices do ciclo em um hiper-vértice.

5 - Verificar lista de adjacência de sucessores, os vértices que não tiverem nenhum sucessor, constituirao meu conjunto de anti-bases.

### Algoritmo para encontrar o Diametro

1 - Iniciar um vetor distância, inicialize com valor padrão 0 e um vetor excentricidade.
2 - Para cada vertice v, realizar uma busca em largura

Busca em Largura -> Primeiro visita todos os adjacentes de um vertice depois os adjacentes dos adjacentes e assim por diante, utilizando uma estrutura de fila.

3 - Durante a busca, para cada vértice adjacente u não visitado, atualize o vetor distância[u] = distância[v] + 1.
4 - No vetor distância pegue o maior valor e guarde como a excentricidade de v, excentricidade[v] = maiorDistância, passe para o proximo vertice v.
5 - No vetor excentricidade pegue o maior valor e esse será o Diametro do grafo.

### Algoritmo para encontrar excentricidade

1 - Iniciar um vetor distância, inicialize com valor padrão 0;
2 - Para um vertice v, realizar uma busca em largura

Busca em Largura -> Primeiro visita todos os adjacentes de um vertice depois os adjacentes dos adjacentes e assim por diante, utilizando uma estrutura de fila.

3 - Durante a busca, para cada vértice adjacente u não visitado, atualize o vetor distância[u] = distância[v] + 1.
4 - No vetor distância pegue o maior valor com isso teremos a excentricidade do vertice.